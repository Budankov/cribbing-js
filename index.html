<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Шпаргалка по JS за конспектом GoIT</title>
      <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/modern-normalize/1.1.0/modern-normalize.min.css"
    />
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <h1>Шпаргалка по JS за конспектом GoIT</h1>
  <h2>Модуль 1 - Заняття 1 - Змінні та типи</h2>

    <p><span>Number</span> - цілі числа і числа з плаваючою комою (крапкою).</p>
    <p><span>String</span> - рядки, послідовність з нуля або більше символів.</p>
    <p><span>Boolean</span> - логічний тип даних, прапорці стану. Всього два значення: true і false.</p>
    <p><span>null</span> - особливе значення, яке по суті означає ніщо</p>
    <p><span>undefined</span> - ще одне спеціальне значення за замовчуванням, коли змінна оголошується, але не ініціалізується, її значення не визначено, їй присвоюється undefined.</p>
    <p><span>typeof</span> - використовується для отримання типу значення змінної. Повертає на місце свого виклику тип значення змінної.</p>
    <p><span>NaN</span> - значенням, що становить не число (Not-A-Number).</p>
    <p><span>Number(val)</span> - приведення до числа, передаючи їй у val те, що потрібно привести до числа.</p>
    <p><span>.isNaN(val)</span> - перевіряє, чи вказане значення є NaN, true - якщо значення val - NaN, false - якщо значення val - не NaN.</p>
    <p><span>.parseInt()</span> - парсить з рядка ціле число.</p>
    <p><span>.parseFloat()</span> - парсить з рядка дробове число.</p>
    <p><span>toFixed()</span> - спосіб додати, а результат скоротити до певного знаку після коми.</p>
    <p><span>Math</span> - один із вбудованих класів, який надає набір методів для роботи з числами.</p>
    <p><span>Math.floor(num)</span> - повертає найбільше ціле число, менше, або яке дорівнює зазначеному числу.</p>
    <p><span>Math.ceil(num)</span> - повертає найменше ціле число, більше, або яке дорівнює зазначеному числу.</p>
    <p><span>Math.round(num)</span> - повертає значення числа, округленого до найближчого цілого.</p>
    <p><span>Math.max(num1, num2, ...)</span> - повертає найбільше ціле число з набору.</p>
    <p><span>Math.min(num1, num2, ...)</span> - повертає найменше ціле число з набору.</p>
    <p><span>Math.pow(base, exponent)</span> - піднесення до степеня.</p>
    <p><span>Math.random()</span> - повертає псевдовипадкове число в діапазоні [0, 1).</p>
    <p><span>${вираз}</span> - шаблонний рядок.</p>
    <p><span>.length</span> - відображає довжину рядка, тобто кількість його символів.</p>
    <p><span>.toLowerCase()</span> і <span>.toUpperCase()</span> - повертають новий рядок у відповідному регістрі, не змінюючи оригінальний рядок.</p>
    <p><span>.indexOf()</span> - повертає позицію (індекс), на якій знаходиться перший збіг підрядка або -1, якщо нічого не знайдено.</p>
    <p><span>.includes()</span> - перевіряє, чи міститься підрядок в рядку, повертає буль - true, якщо міститься, і false - в іншому випадку.</p>
    <p><span>.endsWith()</span> - дозволяє визначити, чи завершується рядок символами (підрядком), зазначеними в дужках, повертаючи true або false.</p>
    <p><span>.replace()</span> і <span>.replaceAll()</span> - повертає новий рядок, в якому перше (replace) або усі збіги (replaceAll) підрядка замінені на вказане значення.</p>
    <p><span>.slice()</span> - метод рядків slice (startIndex, endIndex) використовується для створення копії. Він робить копію від startIndex і до, але не включно endIndex і повертає новий рядок, не змінюючи оригінал. </p>
    <p><span>&&</span> - логічне «І», приводить всі операнди до буля і повертає значення одного з них.</p>
    <p><span>||</span> - логічне «АБО», приводить всі операнди до буля і повертає значення одного з них.</p>
    <p><span>!вираз</span> - логічне «НЕ», оператор ! приводить операнд до буля, якщо необхідно, а потім робить інверсію - змінює його на протилежний true -> false або false -> true.</p>
    
    <h2> Модуль 1 - Заняття 2 - Розгалуження та цикли</h2>
    <p><span>if</span> - «ЯКЩО», виконує інструкцію, якщо зазначена умова виконується (істинно). Якщо умова не виконується (хибно), може бути виконана інша інструкція.</p>
    <p><span>if...else</span> - «ЯКЩО»...ІНШЕ», розширює синтаксис if таким чином, що якщо умова приводиться до false, виконається код у фігурних дужках після оператора else.</p>
    <p><span>else...if</span> - «ІНШЕ»...«ЯКЩО», дозволяє додати після else ще один оператор if з умовою.</p>
    <p><span><умова> ? <вираз_якщо_умова_правдива> : <вираз_якщо_умова_хибна></span> - ьернарний оператор використовується у якості синтаксично коротшої заміни інструкції if...else.</p>
    <p><span>switch</span> - інструкція розгалуження,  «плоскіший» синтаксис if...else. </p>
    <p><span>while</span> - цикл з передумовою — цикл, який виконується, доки правдива якась умова, зазначена до його початку.</p>
    <p><span>do...while</span> - цикл з постумовою - цикл, в якому умова перевіряється після виконання тіла циклу.</p>
    <p><span>for</span> - цикл з лічильником - цикл, в якому певна змінна змінює своє значення із заданого початкового до кінцевого значення з деяким кроком.</p>
    <p><span>break</span> - повністю припиняє виконання циклу і передає управління на рядок після його тіла.</p>
    <p><span>continue</span> - виконання тіла припиняється і управління передається до наступної ітерації.</p>
    
    <h2>Модуль 2 - Заняття 3 - Масиви</h2>
    <p><span>[]</span> - літерал масиву, кожен елемент масиву розділяється комою. Масив - структура даних для зберігання і маніпулювання колекцією індексованих значень.</p>
    <p><span>for...of</span> - оголошує цикл, що перебирає ітерабельні об'єкти, як-от масиви і рядки.</p>
    <p><span>break</span> і <span>continue</span> - перериваємо цикл, continue - виконання тіла припиняється і управління передається на наступну ітерацію</p>
    <p><span>.split()</span> - перетворює рядок в масив, «розбиваючи» його роздільником. Якщо роздільник - це порожній рядок, то створиться масив окремих символів. Роздільником може бути один або декілька символів.</p>
    <p><span>.join()</span> - об'єднує елементи масиву у рядок. У рядку елементи будуть розділені символом або групою символів. Тобто ця операція протилежна методу рядків .split().</p>
    <p><span>.indexOf()</span> - повертає перший індекс, в якому елемент зі значенням value був знайдений в масиві, або число -1, якщо такий елемент відсутній.</p>
    <p><span>.includes()</span> - перевіряє, чи містить масив елемент зі значенням value і повертає true або false відповідно.</p>
    <p><span>.push()</span> - додає один або декілька елементів наприкінці масиву, без необхідності зазначати індекси елементів, що додаються.</p>
    <p><span>.pop()</span> - видаляє останній елемент з кінця масиву і повертає видалений елемент. Якщо масив порожній, метод повертає undefined.</p>
    <p><span>.slice(begin, end)</span> - повертає новий масив, що містить копію частини вихідного масиву, не змінюючи його. Копія створюється з begin і до, але не включно, end - індекси елементів вихідного масиву.</p>
    <p><span>.splice(position, num, sum)</span> - видаляє, додає і замінює елементи у довільному місці масиву. position - вказує на позицію (індекс) першого елемента для видалення, num - визначає кількість елементів, що видаляються, sum - вказує початкову позицію в масиві, куди будуть вставлені нові елементи.</p>
    <p><span>.concat()</span> - об'єднує два або більше масивів в один. Він не змінює масив, на якому викликається, а повертає новий.</p>
    
    <h2>Модуль 2 - Заняття 4 - Функції</h2>
    <p><span>function назва() {}</span> - це підпрограма, незалежна частина коду, призначена для багаторазового виконання конкретної задачі з різними початковими значеннями. назва() - виклики функції назва.</p>
    <p><span>return</span> - використовується для передачі значення з тіла функції у зовнішній код, він відразу ж виходить з функції (припиняє її виконання), і повертає вказане значення у те місце коду, де була викликана функція.</p>
    <p><span>arguments</span> - можна отримати доступ до списку всіх аргументів, яка доступна тільки всередині функції і зберігає всі аргументи у якості псевдомасиву.</p>
    <p><span>Array.from()</span> - метод який створить масив із псевдомасиву. Array.from(arguments).</p>

    <h2>Модуль 3 - Заняття 5 - Об'єкти</h2>
    <p><span>{}</span> - літерал об'єкта.</p>
    <p><span>об'єкт.ім'я_властивості</span> - спосіб отримати доступ до властивості об'єкта.</p>
    <p><span>this</span> - доступ до властивостей об'єкта в методах.</p>
    <p><span>for...in</span> - спеціальний цикл який використовується для перебирання об'єктів, який перебирає ключі об'єкта.</p>
    <p><span>.hasOwnProperty()</span> - для того, щоб дізнатись, чи містить об'єкт власну властивість, який повертає true або false.</p>
    <p><span>Object.keys()</span> - приймає об'єкт і повертає масив ключів його власних властивостей.</p>
    <p><span>Object.values()</span> - приймає об'єкт і повертає масив значень його власних властивостей.</p>
    <p><span>Object.entries()</span> - приймає об'єкт і повертає масив записів, кожен елемент якого, буде ще один масив з 2-х елементів: імені властивості і значення цієї властивості з об'єкта.</p>

    <h2>Модуль 3 - Заняття 6 - Деструктуризація та spread/rest</h2>
    <p><span>...</span> - <b>spread: передача аргументів.</b> Операція ... (spread) дозволяє розподілити колекцію елементів (масив, рядок або об'єкт) в місце, в якому очікується набір окремих значень.</p>
    <p><span>...</span> - <b>spread: створення нового масиву.</b> Операція ... (spread) дозволяє створити копію масиву або «склеїти» довільну кількість масивів в один новий.</p>
    <p><span>...</span> - <b>spread: створення нового об'єкта.</b> Операція ... (spread) дозволяє розподілити властивості довільної кількості об'єктів в один новий.</p>
    <p><span>...</span> - <b>rest: збирання всіх аргументів функції</b> Операція ... (rest) дозволяє зібрати групу незалежних елементів у нову колекцію. Синтаксично - це близнюк операції розподілу, але відрізнити їх просто - розподіл - коли ... знаходиться у правій частині операції присвоювання, а збирання - коли ... знаходиться в її лівій частині.</p>
    <p><span>...</span> - <b>rest: збирання частини аргументів функції</b> Операція ... (rest) також дозволяє зібрати в масив тільки ту частину аргументів, яка необхідна, оголосивши параметри до «збирання».</p>
    <p><span>{} =</span> - Деструктуризація завжди знаходиться у лівій частині операції присвоєння. Деструктуризація дозволяє «розпакувати» значення властивостей об'єкта у локальні змінні.</p>
    <p><span>[] =</span> - Деструктуризація завжди знаходиться у лівій частині операції присвоєння. Деструктуризація дозволяє «розпакувати» послідовно значення властивостей масивів у локальні змінні.</p>

    <h2>Модуль 4 - Заняття 7 - Коллбеки та стрілочні функції</h2>
    <p><span>.forEach()</span> - метод перебирання масиву, який використовується для заміни циклів for і for...of в роботі з колекцією даних.</p>
    <p><span>=></span> - стрілочні функції, мають скорочений, лаконічніший синтаксис, ключове слово function не використовується.</p>

    <h2>Модуль 4 - Заняття 8 - Перебираючі методи масиву</h2>
    <p><span>.map()</span> - використовується для трансформації масиву. Він викликає колбек-функцію для кожного елемента вихідного масиву, а результат її роботи записує у новий масив, який і буде результатом виконання методу.</p>
    <p><span>.flatMap()</span> - аналогічний методу map(), але застосовується у випадках, коли результат - це багатовимірний масив, який необхідно «розгладити».</p>
    <p><span>.filter()</span> - використовується для єдиної операції - фільтрації масиву, тобто, коли необхідно вибрати більше одного елемента з колекції за певним критерієм.</p>
    <p><span>.find()</span> - дозволяє знайти і повернути перший відповідний елемент, після чого перебирання масиву припиняється. Тобто він шукає до першого збігу.</p>
    <p><span>.findIndex()</span> - це сучасна заміна методу indexOf(). Дозволяє виконувати пошук за складнішими умовами, ніж просто рівність. Використовується як для пошуку у масиві примітивів, так і в масиві об'єктів.</p>
    <p><span>.every()</span> - перевіряє, чи проходять всі елементи масиву тест колбек-функції. Повертає true або false.</p>
    <p><span>.some()</span> - перевіряє, чи проходить хоча б один елемент масиву тест колбек-функції. Повертає true або false.</p>
    <p><span>.reduce()</span> - використовується для послідовної обробки кожного елемента масиву із збереженням проміжного результату, як акумулятор. Трохи складніший за інші методи для засвоєння, але результат вартий того.</p>
    <p><span>.sort()</span> - сортує елементи масиву, але на відміну від інших методів перебирання, він сортує вихідний масив.</p>

    <h2>Модуль 5 - Заняття 9 - Ключове слово this</h2>
    <p><span>call()</span> - метод викличе функцію таким чином, що в this буде посилання на об'єкт, а також передасть аргументи, тощо.</p>
    <p><span>apply()</span> - це аналог методу <span>call()</span> за винятком того, що синтаксис передачі аргументів вимагає не перерахування, а масив, навіть якщо аргумент всього один.</p>
    <p><span>bind()</span> - метод використовується коли необхідно не відразу викликати функцію, а передати посилання на неї, причому з прив'язаним контекстом.</p>

    <h2>Модуль 5 - Заняття 10 - Прототипи та класи</h2>
    <p><span>Object.create()</span> - метод створює і повертає новий об'єкт, зв'язуючи його з іншим об'єктом.</p>
    <p><span>class</span> - оголошення класу, починається з ключового слова class, після якого стоїть ім'я класу і фігурні дужки - його тіло. Класи прийнято називати з великої літери, а у назві відображати тип об'єкта (іменника), що створюється.</p>
    <p><span>new ***()</span> - результат виклику - це об'єкт, який називається екземпляром класу, тому що містить дані і поведінку, що описуються класом.</p>
    <p><span>constructor</span> - метод для ініціалізації екземпляра в класі. Якщо він неоголошений, створюється конструктор за замовчуванням - порожня функція, яка не змінює екземпляр.</p>
    <p><span>#</span> - оголошення приватної властивості, до інціалізації в конструкторі - обов'язкове!</p>
    <p><span>get</span> і <span>set</span> - це коротший синтаксис оголошення методів для взаємодії з властивостями. Геттер виконується при спробі отримати значення властивості, а сеттер - при спробі його змінити.</p>
    <p><span>extends</span> - дозволяє реалізувати наслідування класів, коли один клас (дочірній, похідний) наслідує властивості і методи іншого класу (батьківського).</p>
    <p><span>super()</span> - це псевдонім конструктора батьківського класу. В конструкторі дочірнього класу необхідно викликати спеціальну функцію super(аргументи).</p>

</body>
</html>